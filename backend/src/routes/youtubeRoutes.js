const express = require('express');
const router = express.Router();
const { protect } = require('../middleware/authMiddleware');
const axios = require('axios');
const { OpenAI } = require('openai');
const dotenv = require('dotenv');
const path = require('path');
const { exec } = require('child_process');
const fs = require('fs');
const xml2js = require('xml2js');

// Load environment variables
dotenv.config();

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || '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',
});

// Path to yt-dlp executable
const ytDlpPath = path.join(__dirname, '..', 'bin', 'yt-dlp.exe');

/**
 * @route   GET /api/youtube/channel?url=:channelUrl
 * @desc    Fetch YouTube channel videos using yt-dlp
 * @access  Private
 */
router.get('/channel', protect, async (req, res) => {
  try {
    const { url } = req.query;
    
    if (!url) {
      return res.status(400).json({ success: false, message: 'YouTube channel URL is required' });
    }

    // Construct yt-dlp command to get channel videos
    const command = `"${ytDlpPath}" --dump-json --flat-playlist "${url}" --playlist-items 1-30`;

    exec(command, (error, stdout, stderr) => {
      if (error) {
        console.error(`yt-dlp error: ${error.message}`);
        return res.status(500).json({
          success: false,
          message: 'Failed to fetch channel videos',
          error: error.message
        });
      }

      try {
        const videos = stdout
          .trim()
          .split('\n')
          .map(line => JSON.parse(line))
          .filter(video => video.id); // Filter out invalid entries

        return res.status(200).json({
          success: true,
          data: videos
        });
      } catch (parseError) {
        console.error('Error parsing yt-dlp output:', parseError);
        return res.status(500).json({
          success: false,
          message: 'Error parsing channel data',
          error: parseError.message
        });
      }
    });
  } catch (error) {
    console.error('Error fetching YouTube channel videos:', error);
    return res.status(500).json({ 
      success: false, 
      message: error.message || 'Failed to fetch channel videos',
      error: error.toString()
    });
  }
});

/**
 * @route   GET /api/youtube/transcript?url=:youtubeUrl
 * @desc    Fetch YouTube transcript using yt-dlp
 * @access  Private
 */
router.get('/transcript', protect, async (req, res) => {
  try {
    const { url } = req.query;
    
    if (!url) {
      return res.status(400).json({ success: false, message: 'YouTube URL is required' });
    }
    
    // Extract video ID from URL
    const videoId = extractVideoId(url);
    
    if (!videoId) {
      return res.status(400).json({ success: false, message: 'Invalid YouTube URL' });
    }
    
    // Construct yt-dlp command to get transcript
    const command = `"${ytDlpPath}" --skip-download --write-auto-sub --sub-lang en --sub-format json3 --convert-subs srt "${url}" -o "temp_${videoId}"`;
    
    exec(command, async (error, stdout, stderr) => {
      if (error) {
        console.error(`yt-dlp error: ${error.message}`);
        return res.status(500).json({
          success: false,
          message: 'Failed to fetch transcript',
          error: error.message
        });
      }

      try {
        // Read the generated subtitle file
        const subtitleFile = `temp_${videoId}.en.json3`;
        if (!fs.existsSync(subtitleFile)) {
          throw new Error('No subtitles available for this video');
        }

        const subtitles = JSON.parse(fs.readFileSync(subtitleFile, 'utf8'));
        let transcript = '';
        
        if (subtitles.events && subtitles.events.length > 0) {
          transcript = subtitles.events
            .filter(event => event.segs && event.segs.length > 0)
            .map(event => event.segs.map(seg => seg.utf8).join(' '))
            .join(' ');
        }

        // Clean up the temporary file
        fs.unlinkSync(subtitleFile);

        return res.status(200).json({
          success: true,
          data: {
            videoId,
            transcript: transcript.trim(),
            language: 'en',
            isAutoGenerated: true
          }
        });
      } catch (parseError) {
        console.error('Error parsing transcript:', parseError);
        return res.status(500).json({
          success: false,
          message: 'Error parsing transcript data',
          error: parseError.message
        });
      }
    });
  } catch (error) {
    console.error('Error fetching YouTube transcript:', error);
    return res.status(500).json({ 
      success: false, 
      message: error.message || 'Failed to fetch transcript',
      error: error.toString()
    });
  }
});

/**
 * @route   GET /api/youtube/details?videoId=:videoId
 * @desc    Fetch YouTube video details using yt-dlp
 * @access  Private
 */
router.get('/details', protect, async (req, res) => {
  try {
    const { videoId } = req.query;
    
    if (!videoId) {
      return res.status(400).json({ success: false, message: 'YouTube video ID is required' });
    }
    
    // Construct yt-dlp command to get video details
    const command = `"${ytDlpPath}" --dump-json --skip-download "https://www.youtube.com/watch?v=${videoId}"`;
    
    exec(command, async (error, stdout, stderr) => {
      if (error) {
        console.error(`yt-dlp error: ${error.message}`);
        return res.status(500).json({
          success: false,
          message: 'Failed to fetch video details',
          error: error.message
        });
      }

      try {
        // Parse the JSON output
        const videoDetails = JSON.parse(stdout.trim());
        
        return res.status(200).json({
          success: true,
          data: {
            videoId: videoDetails.id,
            title: videoDetails.title,
            description: videoDetails.description,
            thumbnail: videoDetails.thumbnail,
            duration: videoDetails.duration,
            uploadDate: videoDetails.upload_date,
            viewCount: videoDetails.view_count,
            channel: {
              id: videoDetails.channel_id,
              name: videoDetails.channel,
              url: videoDetails.channel_url
            }
          }
        });
      } catch (parseError) {
        console.error('Error parsing video details:', parseError);
        return res.status(500).json({
          success: false,
          message: 'Error parsing video details',
          error: parseError.message
        });
      }
    });
  } catch (error) {
    console.error('Error fetching YouTube video details:', error);
    return res.status(500).json({ 
      success: false, 
      message: error.message || 'Failed to fetch video details',
      error: error.toString()
    });
  }
});

/**
 * @route   POST /api/youtube/analyze
 * @desc    Analyze transcript for LinkedIn content
 * @access  Private
 */
router.post('/analyze', protect, async (req, res) => {
  try {
    const { transcript, preferences } = req.body;
    
    if (!transcript) {
      return res.status(400).json({ success: false, message: 'Transcript is required' });
    }
    
    // Use a simple algorithm to extract key points from transcript
    const sentences = transcript.split(/[.!?]+/).filter(sentence => sentence.trim().length > 0);
    const keyPoints = [];
    
    // Extract key sentences (simplified approach)
    for (let i = 0; i < sentences.length; i += Math.ceil(sentences.length / 5)) {
      if (sentences[i] && sentences[i].length > 40) {
        keyPoints.push(sentences[i].trim());
      }
      
      if (keyPoints.length >= 5) break;
    }
    
    return res.status(200).json({
      success: true,
      data: {
        content: transcript.substring(0, 1000) + (transcript.length > 1000 ? '...' : ''),
        keyPoints,
        format: preferences?.format || 'post',
        tone: preferences?.tone || 'professional'
      }
    });
  } catch (error) {
    console.error('Error analyzing transcript:', error);
    return res.status(500).json({ 
      success: false, 
      message: error.message || 'Failed to analyze transcript',
      error: error.toString()
    });
  }
});

/**
 * @route   POST /api/youtube/save
 * @desc    Save YouTube video to database
 * @access  Private
 */
router.post('/save', protect, async (req, res) => {
  try {
    const { videoData } = req.body;
    
    if (!videoData || !videoData.videoId) {
      return res.status(400).json({ success: false, message: 'Video data is required' });
    }
    
    // In a real implementation, you would save to a database
    // For now we'll just return success
    
    return res.status(200).json({
      success: true,
      message: 'Video saved successfully',
      data: {
        id: videoData.id || Date.now().toString(), // Just a mock ID
        videoId: videoData.videoId,
        savedAt: new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('Error saving YouTube video:', error);
    return res.status(500).json({ 
      success: false, 
      message: error.message || 'Failed to save video',
      error: error.toString()
    });
  }
});

// Helper function to extract YouTube video ID from URL
function extractVideoId(url) {
  try {
    let videoId = null;
    
    // Handle different URL formats
    if (url.includes('youtube.com/watch')) {
      const urlObj = new URL(url);
      videoId = urlObj.searchParams.get('v');
    } else if (url.includes('youtu.be/')) {
      const urlParts = url.split('/');
      videoId = urlParts[urlParts.length - 1].split('?')[0];
    } else if (url.includes('youtube.com/embed/')) {
      const urlParts = url.split('/');
      videoId = urlParts[urlParts.length - 1].split('?')[0];
    }
    
    return videoId;
  } catch (error) {
    console.error('Error extracting video ID:', error);
    return null;
  }
}

module.exports = router; 